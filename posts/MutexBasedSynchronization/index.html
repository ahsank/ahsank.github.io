<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-60YTC6HS65"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-60YTC6HS65'); </script> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>Mutex-Based Synchronization</title> <header> <div class=blog-name ><a href="/">Ahsan Khan</a></div> <nav> <ul> <li><a href="/">Main</a> <li><a href="/about//">About</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=mutex-based_synchronization ><a href="#mutex-based_synchronization" class=header-anchor >Mutex-Based Synchronization</a></h1> <p>When designing a high-performance system, one of the fundamental decisions to make is the memory model and synchronization strategy. Consider a simple multithreaded cache manager with a single interface <code>get&#40;key&#41; -&gt; value</code>, where the key represents the file name and the value represents its content. The <code>get</code> operation involves checking if the entry is present in the hash table. If not, the system loads the content from disk, inserts it into the hash table, and then returns the content.</p> <p>Even for this basic system, synchronization of access to the hash table is necessary. The pseudocode for such a system can be summarized as follows:</p> <ol> <li><p>Check if the entry is present in the cache by</p> <ul> <li><p>Locking a mutex</p> <li><p>Checking if the entry is present in the hash table</p> <li><p>Unlocking the mutex</p> </ul> <li><p>If the entry was present, go to step 4. Otherwise, read the value from disk &#40;possibly in a separate thread or thread pool&#41;.</p> <li><p>Add the value to the cache</p> <ul> <li><p>Lock the mutex</p> <li><p>Add the value to the hash table</p> <li><p>Unlock the mutex</p> </ul> <li><p>Return the value</p> </ol> <h2 id=benchmarking_mutex_locking_performance ><a href="#benchmarking_mutex_locking_performance" class=header-anchor >Benchmarking Mutex Locking Performance</a></h2> <p>To simulate a similar pattern, we can perform the following operations:</p> <ol> <li><p>Lock a mutex and perform CPU-intensive operations on a data structure, then unlock the mutex.</p> <li><p>Perform IO/network operations that can be parallelized.</p> <li><p>Lock the mutex again and perform additional operations on the data structure before unlocking the mutex.</p> </ol> <p>In this blog, we will conduct a benchmark to observe how mutex locking affects performance. Subsequently, we plan to evaluate different libraries and alternatives.</p> <h3 id=simulating_the_operation ><a href="#simulating_the_operation" class=header-anchor >Simulating the Operation</a></h3> <p>Let&#39;s use the following sequence of operations in C&#43;&#43;:</p> <pre><code class="cpp hljs"><span class=hljs-keyword >using</span> cachetype = std::unordered_map&lt;std::string, std::string&gt;;
<span class=hljs-type >const</span> <span class=hljs-type >unsigned</span> <span class=hljs-type >int</span> max_iter = <span class=hljs-number >1000</span>;

<span class=hljs-comment >// Simulate CPU operation by just incrementing a string value</span>
<span class=hljs-comment >// in a hash table</span>
<span class=hljs-function ><span class=hljs-keyword >inline</span> std::string <span class=hljs-title >get_key</span><span class=hljs-params >(<span class=hljs-type >int</span> i)</span> </span>{<span class=hljs-keyword >return</span> cache_key + std::<span class=hljs-built_in >to_string</span>(i);}

<span class=hljs-function ><span class=hljs-keyword >inline</span> <span class=hljs-type >void</span> <span class=hljs-title >calc</span><span class=hljs-params >(cachetype&amp; cache)</span> </span>{
    <span class=hljs-comment >// Some complex calculation</span>
    <span class=hljs-keyword >for</span> (<span class=hljs-type >int</span> i=<span class=hljs-number >0</span>; i &lt; num_calc; i++) {
        <span class=hljs-keyword >auto</span> key = <span class=hljs-built_in >get_key</span>(i);
        <span class=hljs-keyword >auto</span> str = cache[key];
        cache[key] = str.<span class=hljs-built_in >length</span>() == <span class=hljs-number >0</span> ? <span class=hljs-string >&quot;1&quot;</span> : std::<span class=hljs-built_in >to_string</span>(std::<span class=hljs-built_in >stoi</span>(str) + <span class=hljs-number >1</span>);
    }
}

<span class=hljs-comment >// Simulate an  IO operation by just sleep</span>
<span class=hljs-function ><span class=hljs-keyword >inline</span> <span class=hljs-type >void</span> <span class=hljs-title >fake_io</span> <span class=hljs-params >(std::chrono::duratin sleep_time)</span> </span>{
    std::this_thread::<span class=hljs-built_in >sleep_for</span>(sleep_time);
}</code></pre> <p>For the lock-free version of the benchmark:</p> <pre><code class="cpp hljs"><span class=hljs-function ><span class=hljs-type >static</span> <span class=hljs-type >void</span> <span class=hljs-title >cache_calc</span><span class=hljs-params >(cachetype&amp; cache,
    std::chrono::duratin sleep_time)</span> </span>{
    <span class=hljs-keyword >for</span> (<span class=hljs-type >int</span> i=<span class=hljs-number >0</span>; i &lt; max_iter; i++) {
        <span class=hljs-built_in >calc</span>(cache);
        <span class=hljs-built_in >fake_io</span>(sleep_time);
        <span class=hljs-built_in >calc</span>(cache);
    }
}</code></pre> <p>Here, <code>sleep_time</code> simulates the I/O intensity of the application, and we will perform the benchmark with values of 8us and 64us.</p> <p>The benchmark results for 1000 iterations:</p> <pre><code class="console hljs">----------------------------------------------------------------
Benchmark                      Time             CPU   Iterations
----------------------------------------------------------------
BM_cachecalc/8              85.0 ms        0.044 ms          100
BM_cachecalc/64              155 ms        0.044 ms          100</code></pre> <p>Adding mutex in a single-threaded program surprisingly shows no overhead, indicating minimal impact when there is no contention:</p> <pre><code class="cpp hljs"><span class=hljs-function ><span class=hljs-type >static</span> <span class=hljs-type >void</span> <span class=hljs-title >cache_calc_mutex</span><span class=hljs-params >(cachetype&amp; cache, std::mutex&amp; m,
    std::chrono::microseconds sleep_time)</span> </span>{
    <span class=hljs-keyword >for</span> (<span class=hljs-type >int</span> i=<span class=hljs-number >0</span>; i &lt; max_iter; i++) {
        {
            <span class=hljs-function >std::scoped_lock <span class=hljs-title >lck</span><span class=hljs-params >(m)</span></span>;
            <span class=hljs-built_in >calc</span>(cache);
        }
        <span class=hljs-built_in >fake_io</span>(sleep_time);
        {
            <span class=hljs-function >std::scoped_lock <span class=hljs-title >lck</span><span class=hljs-params >(m)</span></span>;
            <span class=hljs-built_in >calc</span>(cache);
        }
    }
}</code></pre> <p>Benchmark results with mutex:</p> <pre><code class="console hljs">----------------------------------------------------------------
Benchmark                      Time             CPU   Iterations
----------------------------------------------------------------
BM_cachecalc_mutex/8        84.8 ms        0.048 ms          100
BM_cachecalc_mutex/64        155 ms        0.042 ms          100</code></pre> <p>Running the same calculation in 8 threads yields the following benchmark results:</p> <pre><code class="cpp hljs"><span class=hljs-keyword >constexpr</span> <span class=hljs-type >unsigned</span> <span class=hljs-type >int</span> num_tasks = <span class=hljs-number >8</span>

<span class=hljs-type >static</span> <span class=hljs-type >void</span> <span class=hljs-built_in >cache_calc_async</span>(cachetype&amp; map,
    std::chrono::microseconds sleep_time) {
    std::queue&lt;std::future&lt;<span class=hljs-type >void</span>&gt;&gt; futures;
    std::mutex m;

    <span class=hljs-keyword >for</span> (<span class=hljs-type >int</span> i=<span class=hljs-number >0</span>; i &lt; max_iter; i++) {
        futures.<span class=hljs-built_in >push</span>(std::<span class=hljs-built_in >async</span>([&amp;]{
            {
                std::scoped_lock <span class=hljs-built_in >lck</span>(m);
                <span class=hljs-built_in >calc</span>(map);
            }
            <span class=hljs-built_in >fake_io</span>(sleep_time);
            {
                std::scoped_lock <span class=hljs-built_in >lck</span>(m);
                <span class=hljs-built_in >calc</span>(map);
            }
        }));
        <span class=hljs-keyword >while</span> (futures.<span class=hljs-built_in >size</span>() &gt;= num_tasks) {
            futures.<span class=hljs-built_in >front</span>().<span class=hljs-built_in >wait</span>();
            futures.<span class=hljs-built_in >pop</span>();
        }
    }
    <span class=hljs-keyword >while</span>(!futures.<span class=hljs-built_in >empty</span>()) {
        futures.<span class=hljs-built_in >front</span>().<span class=hljs-built_in >wait</span>();
        futures.<span class=hljs-built_in >pop</span>();
    }
}</code></pre> <p>Benchmark results for 8 threads:</p> <pre><code class="console hljs">----------------------------------------------------------------
Benchmark                      Time             CPU   Iterations
----------------------------------------------------------------
BM_cachecalc_async/8        17.5 ms         13.6 ms           48
BM_cachecalc_async/64       24.0 ms         15.4 ms           44</code></pre> <p>For the full code of the benchmark, you can visit <a href="https://github.com/ahsank/EvaluateIPC/blob/master/tests/mutexbench.cc">EvaluateIPC GitHub Repository</a></p> <script src="https://utteranc.es/client.js" repo="ahsank/ahsank.github.io" issue-term=pathname  label=Comment  theme=github-light  crossorigin=anonymous  async> </script> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Ahsan Khan. Last modified: January 07, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>. </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>